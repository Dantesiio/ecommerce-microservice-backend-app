pipeline {
    agent none
    options {
        ansiColor('xterm')
        timestamps()
    }
    environment {
    REGISTRY_HOST = "docker.io"
    REGISTRY_REPO = "dantesiio/ecommerce-backend"
        DOCKER_CREDS_ID = "docker-registry"
        GIT_CREDS = credentials('git-credentials')
        KUBECONFIG_STAGE_ID = "kubeconfig-stage"
    }
    stages {
        stage('Checkout') {
            agent { label 'docker' }
            steps {
                deleteDir()
                checkout([
                    $class: 'GitSCM',
                    userRemoteConfigs: [[credentialsId: GIT_CREDS, url: env.GIT_URL ?: 'https://github.com/Dantesiio/ecommerce-microservice-backend-app.git']],
                    branches: [[name: env.BRANCH_NAME ?: 'dev']],
                    extensions: [[$class: 'CloneOption', depth: 0, shallow: false]]
                ])
            }
        }
        stage('Build & Unit Tests (Stage)') {
            agent { label 'docker' }
            steps {
                sh './mvnw -pl proxy-client,user-service,product-service,order-service,payment-service,shipping-service clean verify'
                stash name: 'maven-artifacts', includes: '**/target/**/*', useDefaultExcludes: false
                stash name: 'test-reports', includes: '**/target/surefire-reports/*.xml', allowEmpty: true
            }
        }
        stage('Build Container Images') {
            agent { label 'docker' }
            steps {
                script {
                    unstash 'maven-artifacts'
                    def services = ['proxy-client', 'user-service', 'product-service', 'order-service', 'payment-service', 'shipping-service']
                    services.each { svc ->
                        def imageTag = "${env.REGISTRY_HOST}/${env.REGISTRY_REPO}:${svc}-${env.GIT_COMMIT}"
                        sh """
                            docker build \
                                -f ${svc}/Dockerfile \
                                -t ${imageTag} \
                                ${svc}
                        """
                    }
                }
            }
        }
        stage('Push Images') {
            agent { label 'docker' }
            steps {
                script {
                    def services = ['proxy-client', 'user-service', 'product-service', 'order-service', 'payment-service', 'shipping-service']
                    withCredentials([usernamePassword(credentialsId: env.DOCKER_CREDS_ID, usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                        sh """
                            echo "${DOCKER_PASS}" | docker login ${env.REGISTRY_HOST} \
                                --username "${DOCKER_USER}" \
                                --password-stdin
                        """
                        services.each { svc ->
                            def imageRef = "${env.REGISTRY_HOST}/${env.REGISTRY_REPO}:${svc}-${env.GIT_COMMIT}"
                            sh "docker push ${imageRef}"
                        }
                    }
                }
            }
        }
        stage('Deploy to Kubernetes (Stage)') {
            agent { label 'k8s' }
            steps {
                script {
                    def workspaceDir = pwd()
                    def kubectlPath = "${workspaceDir}/kubectl"
                    sh """
                        if [ ! -x \"${kubectlPath}\" ]; then
                            curl -sSL -o \"${kubectlPath}\" https://dl.k8s.io/release/v1.28.4/bin/linux/amd64/kubectl
                            chmod +x \"${kubectlPath}\"
                        fi
                    """
                    withCredentials([file(credentialsId: env.KUBECONFIG_STAGE_ID, variable: 'KUBECONFIG_STAGE_FILE')]) {
                        def kubeconfigPath = "${workspaceDir}/kubeconfig-stage.yaml"
                        withEnv([
                            "KUBE_CONFIG_LOCAL=${kubeconfigPath}",
                            "KUBECONFIG=${kubeconfigPath}",
                            "KUBE_STAGE_CLUSTER_ENDPOINT=${env.KUBE_STAGE_CLUSTER_ENDPOINT ?: ''}"
                        ]) {
                            sh '''
                                cp "$KUBECONFIG_STAGE_FILE" "$KUBE_CONFIG_LOCAL"
                                if [ -n "$KUBE_STAGE_CLUSTER_ENDPOINT" ]; then
                                    perl -0pi -e "s#server: https://[^\\s]+#server: $KUBE_STAGE_CLUSTER_ENDPOINT#" "$KUBE_CONFIG_LOCAL"
                                elif grep -q 'server: https://127.0.0.1' "$KUBE_CONFIG_LOCAL"; then
                                    perl -0pi -e "s#server: https://127\\.0\\.0\\.1:(\\d+)#server: https://host.docker.internal:\\1#" "$KUBE_CONFIG_LOCAL"
                                fi
                            '''
                            sh "${kubectlPath} apply -k k8s/overlays/stage"
                        }
                    }
                }
            }
        }
        stage('Smoke Tests') {
            agent { label 'k8s' }
            steps {
                script {
                    def workspaceDir = pwd()
                    def kubectlPath = "${workspaceDir}/kubectl"
                    sh """
                        if [ ! -x \"${kubectlPath}\" ]; then
                            curl -sSL -o \"${kubectlPath}\" https://dl.k8s.io/release/v1.28.4/bin/linux/amd64/kubectl
                            chmod +x \"${kubectlPath}\"
                        fi
                    """
                    withCredentials([file(credentialsId: env.KUBECONFIG_STAGE_ID, variable: 'KUBECONFIG_STAGE_FILE')]) {
                        def kubeconfigPath = "${workspaceDir}/kubeconfig-stage.yaml"
                        withEnv([
                            "KUBE_CONFIG_LOCAL=${kubeconfigPath}",
                            "KUBECONFIG=${kubeconfigPath}",
                            "KUBE_STAGE_CLUSTER_ENDPOINT=${env.KUBE_STAGE_CLUSTER_ENDPOINT ?: ''}"
                        ]) {
                            sh '''
                                cp "$KUBECONFIG_STAGE_FILE" "$KUBE_CONFIG_LOCAL"
                                if [ -n "$KUBE_STAGE_CLUSTER_ENDPOINT" ]; then
                                    perl -0pi -e "s#server: https://[^\\s]+#server: $KUBE_STAGE_CLUSTER_ENDPOINT#" "$KUBE_CONFIG_LOCAL"
                                elif grep -q 'server: https://127.0.0.1' "$KUBE_CONFIG_LOCAL"; then
                                    perl -0pi -e "s#server: https://127\\.0\\.0\\.1:(\\d+)#server: https://host.docker.internal:\\1#" "$KUBE_CONFIG_LOCAL"
                                fi
                            '''
                            sh "${kubectlPath} -n ecommerce-stage rollout status deployment/proxy-client --timeout=180s"
                            sh "${kubectlPath} -n ecommerce-stage run smoke-tests --rm --restart=Never --image=curlimages/curl -- http://proxy-client.ecommerce-stage.svc.cluster.local:8900/app/actuator/health"
                        }
                    }
                }
            }
        }
    }
    post {
        always {
            node('docker') {
                script {
                    try {
                        unstash 'test-reports'
                    } catch (err) {
                        echo "No test reports to unstash: ${err.message}"
                    }
                }
                junit allowEmptyResults: true, testResults: '**/target/surefire-reports/*.xml'
                cleanWs()
            }
        }
    }
}
